# Function

> 注意: 这一章仅仅讨论函数默认参数, 重载和模板!!!!

## 函数默认参数

默认参数指的是当函数调用时可省略了的参数可以自动被一个默认值补全.

比方说, 假如将`void wow(int n)` 设置成`n`有默认值为`1`, 则函数调用`wow()`相当于`wow(1)`.

默认值是十分有用的, 可以减少程序员的一些心智负担.

那么如何设置默认参数呢?

***答案是必须通过函数原型.***

编译器通过查看原型来了解函数所使用的参数数目, 因此,函数原型也必须将可能的默认参数告诉程序.

方法就是将值赋给原型中的参数.

例如:
```javascript
void wow(int n = 0); // function prototype

void wow(int n) // 函数定义照旧
{
    //.....
}
```

需要注意的是, 函数的默认参数是从右到左的.也就是说, 如果要将某个位置的参数设置默认值, 那么这个参数右边的所有参数都需要设置默认值.
<br/>

## 函数重载

函数重载就是指可以有多个同名的汉书, 由此实现函数的多态, 使得函数更能够适用.

函数重载的关键就是函数的参数列表---- 也称为函数特征标(function signature).

如果两个函数的参数数目和类型相同, 同时参数的排列顺序也相同, 则它们的特征标相同.

Cpp允许定义名称相同的函数, 条件是它们的特征标不同.

例如可以定义以下同名函数`print()`:
```javascript
void print(const char *str, int width); // #1
void print(double d, int width); // #2
void print(long l, int width); // #3
void print(int i, int width); // #4
void print(const char *str); // #5 
```
使用`print`函数时, 编译器将使用特征标分辨对应的函数调用:
```javascript
print("pank", 15); // use #1
print("sysu"); // use #5
print(1999.0, 10); // use #2
print(1999, 12); // use #4
print(1999L, 15); // use #3
```

如果是这样的呢?
```javascript
usigned int year = 2345;
print(year, 6);  // ambiguous call
```
`print`现在不与任何函数原型匹配, 但没有匹配的原型并不会自动停止使用其中的某个函数, 而是尝试通过参数的类型转换来寻找最佳匹配项.

我们发现, 这个调用有三种转换可以使得这个调用找到匹配.在这种情况下, 编译器将报错!

还有需要注意的是, `T t` 是等价于 `T &t`的, 在函数重载来看.

因此以下的两个调用时不能共存的:
```javascript
double cube(double x);
double cube(double &x);
```
不过, 函数重载却区分`const`和非`const`变量! <br/>
以下是可以的:
```javascript
input(const char *str);
input(char *str);
```

## 函数重载与默认参数

虽然函数重载很不错, 但不要滥用! 要时刻明白这个函数的具体功能如何, 再来思考是否需要函数重载还是只要默认参数就行了.

一般来说, 仅当函数基本上执行相同的任务, 但使用不同的形式的数据时, 才应该采用函数重载.

使用一个带默认参数的函数要好些, 只需编写一个函数, 程序也只需为一个函数请求内存.

然而如果需要使用不同的类型的参数, 则还是选函数重载.
<br/>

函数模板

函数模板一般主要应用在偏向于数据类型无关, 偏向于算法统一的场景.

有了函数模板, 就可以些一套函数, 为多种类型所使用.

例如以下一个交换模板函数:
```javascript
template <class T>
void swap(T &a, T &b)
{
    T temp = a;
    a = b;
    b = temp;
}
```
如果不嫌字多的话, `class`可以被`typename`.

那么就用一下:
```javascript
int main()
{
    int a = 12;
    int b = 13;

    swap<int>(a, b); //=> a = 13, b = 12; use swap<int>

    double c = 13.0;
    double d = 16.8;

    swap(c, d); //=> c = 16.8, d = 13.0; use swap<double>
}
```
这里的使用, 可以把后面的尖括号去掉, 因为编译器会自动根据参数推断出对应的类型, 然后生成模板对应的实例化.

不过还是建议, 别嫌麻烦, 最好就加上尖括号, 一是为了可读性, 让人知道这是使用模板的, 二是应付可能而来的参数类型不是十分匹配的问题, 如果用了尖括号, 那么就表明强制使用模板, 并且生成指定类型的模板, 对于那些类型稍微不匹配的, 也可以强制类型转化.

### 函数模板重载 

对于业务目的一致, 算法一致, 需要面向不同类型, 函数模板是个不错的选择, 我们只写一个就能应付不同的类型.

然而对于某一类类型, 我们的业务目的是大致相同的, 但是所用的算法却有些许不同. 或者需要不同特征标, 来完成同一个业务目的, 并且算法有可能有不同. 这两种情况单单使用函数模板是不足以应付的.

就比如说上面的`swap`模板, 如果将它用到数组上, 似乎没什么问题, 交换指针也是可以的, 但是如果我还想要指定有多少个元素去交换呢? 

这个时候就要使用函数模板重载了.
例如, 为了实现刚刚的需求, 就可以重载一个`swap`, 让这个重载版本专门用于指定数组元素个数的交换:
```javascript
template <class T>
void swap(T *a, T *b, int n)
{
    T temp;
    for(int i = 0; i < n; i++)
    {
        temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}
```
这个函数重载模板就能很好的应付前面的情况.

### 模板的具体化
但即使如此, 模板还是有些尴尬之处的.
就比如说, 假如有这样的模板函数:
```javascript
template <class T>
T add(const T &a, const T &b)
{
    return a + b;
}
```
如果要让这个函数模板去处理某些不支持加法运算的类型就麻烦了! 指针不能用, 有些代表位置坐标的结构不能用(当然其实可以通过运算符重载解决), 函数模板重载一个有类似业务功能和算法是不可能的.

而Cpp给出的解决方案是,专门为特定类型定制具体化的模板.

让我们看一下如下的结构:
```javascript
struct Job
{
    char name[40];
    double salary;
    int floor;
}
```
假设我们需要交换着两个结构的内容, 原来的`swap`模板是可以工作的, 因为Cpp允许将一个结构赋给另一个结构.

但是假如我只想交换后两个成员, 而保留第一个成员呢?

那么就让函数模板的显式具体化上场吧!

当编译器找到于函数调用匹配的具体化定义时, 将使用这个定义,而不再寻找模板.

具体化的用法如下:
```javascript
template <>
void swap<Job>(Job &j1, Job &j2)
{
    double d;
    int i;

    d = j1.salary;
    j1.salary = j2.salary;
    j2.salary = d;

    i = j1.floor;
    j1.floor = j2.floor;
    j2.floor = i;
}
```
函数模板具体化, 就是以`template<>`打头, 然后函数名后面加上用尖括号包裹的对应的类型名(这个可省略), 然后后面的参数列表其实就是原来的`swap`模板参数的替换, 格式是一个样的.

进一步了解函数模板, 还需要了解实例化和具体化.

记住, 在代码中包含的函数模板本身并不会生成函数定义, 它只是一个用于生成函数定义的方案.

而编译器使用模板为特定的类型生成函数定义时, 得到的是函数模板实例.

函数调用`swap(i. j)`会生成一个对应类型的实例, 这种实例化被称为隐式实例化.

当然, 我们也可以显式的实例化函数模板:
```javascript
template void swap<int>(int &, int &);
```
这个尖括号也是可以被省略的, 跟显式具体化很相似, 但需要注意, 具体化是以`template<>`打头的, 而实例化就是`template`.

还可以通过在程序中使用函数来实现显式实例化:
```javascript
template <class T>
T add(const T &a, const T &b)
{
    return a + b;
}
....
int main()
{
    int m = 6;
    double x = 10.2;
    double result = add<double>(x, m);
}
```
如果使用隐式实例化是不匹配的, 但通过在这里使用`add<double>(x, m)`, 可以强制为`double`类型实例化.

那个加了`template`的实例化很少用, 并且还容易跟具体化混淆, 建议使用这种的显式实例化.

> 隐式实例化, 显式实例化和显式具体化统称为具体化.
<br/>

## 函数版本选择

有了默认参数, 函数重载和函数模板, 我们可以写出多个同名难过的函数, 不过调用这些函数时, 我们就要多加考虑了, 那么如何确定我的函数调用是我想要的版本而不是其他, 或者我的调用如何才能不起歧义?

这里面的具体细节很多, 现在只能说明个大概.

当看到函数的调用时, 如果有很多同名函数, 那么编译器会先去看非模板函数, 如果找到了最佳匹配, 那么就停止寻找,就用这个函数版本, 如果没有找到, 那么就回去寻找匹配的模板. 值得注意的是, 如果有一个函数模板具体化和一个通用函数模都完美匹配时, 编译器会偏爱具体化的那位, 总的来说, 越具体, 优先级就越高.如果都没有完美的匹配, 那么就又重新回到非模板函数, 看看是不是可以通过参数的类型转换而得到匹配, 如果有, 那就它了, 然后函数模板, 如此进行下去.
如果真的找不出来, 或者一查就有多个同级的匹配函数, 编译器就会报错.

还有就是"完美匹配"不是真正的一丝不苟的匹配, 它是允许一些无关紧要的转换的, 例如, `const Type` 和 `const Type&`.

为什么就只说个大概?

 因为在实际情况下, 这种复杂的寻找是罕见的, 而如果真的出现这种情况, 你该好好反思一下自己, 然后自己调整函数的编写结构(当然, 如果你这是炫技或者就是单纯为了学习测试一下, 就当我没说).

当同名函数同时纠缠起默认参数, 函数重载, 函数模板, 那只能说你这个编写绝对有问题, 你很可能是滥用了!

我们应当明确这三者的使用场景.

对于日常的编写, 编写函数模板是没有多大用处的. 原因也很好理解, 你这个项目里的某个函数能用到的类型一只手不到就能数过来, 这个函数的所要的通用性本来就不强, 简简单单, 老老实实的使用默认参数或者非模板的函数重载反倒是个不错的选择.

一般情况下, 函数模板的重度使用者就是库作者, 因为库一般是面向一般对象, 为了普遍对象寻求一个通用的解法或算法.

如果确实要使用函数模板, 那么就要明确模板具体化和模板重载的使用场景.

一般来说, 函数模板重载是为了某一类类型或者确实需要不同的特征标函数解决问题而产生的.

而函数具体化, 则是从模板分叉出来, 并且特征标或者说参数的格式是一样的. 还有与函数模板重载最大的不同就是, 具体化仅仅是为了弥补原本函数模板在某个(不是某类)类型的表现补足而产生的, 专门为这个例外类型, 写一个参数格式与原模版完全相同, 但实现不同的特化函数版本.

还有就是, 要审慎的去使用同名函数, 有些时候非同名函数反倒更加合适. 什么时候比较需要使用同名函数呢?
那就是这个同名函数如它函数名那样, 就是为了解决同一类问题. 就比如说那个`swap`, 如果真的要再写一个`swap`就要考虑, 即将要写的这个同名函数真的是如其名那样主要是做交换工作的吗? 如果不是, 那么请用另外一个函数名表示你那个函数.

> 总之,凡是都不能滥用! 过犹不及! 我认为为了可读性和可维护性, 能用不同名函数就尽量用.

>  当你打算写一个函数重载时, 就要想想这个可不可以通过默认参数解决? 或者就把这个原本是重载的函数修改一下名字, 这绝不是愚蠢的表现. 就比如说C标准库的`strcpy`和`strncpy`, 不用重载两个`strcpy`而是分成两个不同名函数反倒更加好看,(虽然这可能是因为当时无法实现重载)

>当你想要重载一个函数模板的时候, 真的要用重载吗? 重新写一个不同名字的模板就行了. 就比如说上面的`swap`模板, 还有一个专门针对数组的`swap`重载, 我们是不是可以把这个重载改个名字,比如说叫`swap_arr`是不是更能让人明白而少烧点脑?
